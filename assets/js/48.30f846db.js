(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{190:function(e,t,n){"use strict";n.r(t);var r=n(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"vue源码解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue源码解析","aria-hidden":"true"}},[e._v("#")]),e._v(" vue源码解析")]),e._v(" "),n("h2",{attrs:{id:"目录设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录设计","aria-hidden":"true"}},[e._v("#")]),e._v(" 目录设计")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 共享代码\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[e._v("compiler: 包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。")]),e._v(" "),n("li",[e._v("core: Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。")]),e._v(" "),n("li",[e._v("platform: platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。")]),e._v(" "),n("li",[e._v('server: 所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js。主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。')]),e._v(" "),n("li",[e._v("sfc：.vue 文件内容解析成一个 JavaScript 的对象。")]),e._v(" "),n("li",[e._v("shared：定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。")])]),e._v(" "),n("h2",{attrs:{id:"源码构建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源码构建","aria-hidden":"true"}},[e._v("#")]),e._v(" 源码构建")]),e._v(" "),n("p",[e._v("基于Rollup(相对于webpack来讲，更加轻量)，相关配置都在 scripts 目录下。(npm run build执行的是script下的build.js文件，各种版本的配置在config.js)。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("'web-runtime-cjs': {\n  entry: resolve('web/entry-runtime.js'),\n  dest: resolve('dist/vue.runtime.common.js'),\n  format: 'cjs',\n  banner\n},\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("p",[e._v("遵循Rollup构建规则，入口文件，输出文件等。format 属性表示构建的格式，cjs 表示构建出来的文件遵循 CommonJS 规范，es 表示构建出来的文件遵循 ES Module 规范。 umd 表示构建出来的文件遵循 UMD 规范。")]),e._v(" "),n("h3",{attrs:{id:"runtime-only-vs-runtime-compiler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runtime-only-vs-runtime-compiler","aria-hidden":"true"}},[e._v("#")]),e._v(" Runtime Only VS Runtime + Compiler")]),e._v(" "),n("ul",[n("li",[e._v("Runtime Only\n一般开发的时候用，配合webpack的vue-loader把.vue编译成js。因为只有runtime代码，所以更轻量。")]),e._v(" "),n("li",[e._v("Runtime + Compiler\n如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板。在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。")])]),e._v(" "),n("h2",{attrs:{id:"入口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#入口","aria-hidden":"true"}},[e._v("#")]),e._v(" 入口")]),e._v(" "),n("p",[e._v("分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 entry-runtime-with-compiler.js。从中可以看到引入Vue的文件，真正初始化 Vue 的地方，在 src/core/index.js 中,有两个关键import Vue from './instance/index' 和 initGlobalAPI(Vue)。")]),e._v(" "),n("ul",[n("li",[e._v("instace/index：\n一个用 Function 实现的Vue类，我们只能通过 new Vue 去实例化它。并且给Vue.prototype上扩展一些方法")]),e._v(" "),n("li",[e._v("initGlobalAPI:\n给 Vue 这个对象本身扩展全局的静态方法")])]),e._v(" "),n("h2",{attrs:{id:"new-vue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-vue","aria-hidden":"true"}},[e._v("#")]),e._v(" new Vue")]),e._v(" "),n("p",[e._v("'instance/init'中，Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等，在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。")]),e._v(" "),n("h2",{attrs:{id:"mounted"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mounted","aria-hidden":"true"}},[e._v("#")]),e._v(" mounted")]),e._v(" "),n("p",[e._v("compiler 版本的 $mount 在 src/platform/web/entry-runtime-with-compiler.js 文件中定义：")]),e._v(" "),n("ol",[n("li",[e._v("缓存了原型上的 $mount 方法，再重新定义该方法")]),e._v(" "),n("li",[e._v("对el做出限制（不能说html,body）")]),e._v(" "),n("li",[e._v("如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的")]),e._v(" "),n("li",[e._v("调用原先缓存的 $mount 方法挂载")])]),e._v(" "),n("blockquote",[n("p",[e._v("原先原型上的 $mount 方法在 src/platform/web/runtime/index.js 中定义，之所以这么设计完全是为了复用，因为它是可以被 runtime only 版本的 Vue 直接使用的。")])]),e._v(" "),n("p",[e._v("$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中：核心是实例化一个渲染Watcher，它调用了updateComponent=>vm._render=>先生成虚拟 Node，最终调用 vm._update 更新 DOM。")]),e._v(" "),n("blockquote",[n("p",[e._v("Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数")])]),e._v(" "),n("ul",[n("li",[e._v("_render:把实例渲染成一个虚拟 Node。最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node")])])])}],!1,null,null,null);s.options.__file="vue源码解析.md";t.default=s.exports}}]);