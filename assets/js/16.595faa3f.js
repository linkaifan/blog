(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{165:function(a,t,s){a.exports=s.p+"assets/img/webkitflow.85a66640.png"},203:function(a,t,s){"use strict";s.r(t);var r=[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器","aria-hidden":"true"}},[a._v("#")]),a._v(" 浏览器")]),a._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#浏览器"}},[a._v("浏览器")])]),r("li",[r("a",{attrs:{href:"#简介"}},[a._v("简介")]),r("ul",[r("li",[r("a",{attrs:{href:"#讨论的浏览器"}},[a._v("讨论的浏览器")])]),r("li",[r("a",{attrs:{href:"#主要功能"}},[a._v("主要功能")])]),r("li",[r("a",{attrs:{href:"#高层结构"}},[a._v("高层结构")])])])]),r("li",[r("a",{attrs:{href:"#呈现引擎"}},[a._v("呈现引擎")]),r("ul",[r("li",[r("a",{attrs:{href:"#各浏览器引擎"}},[a._v("各浏览器引擎")])]),r("li",[r("a",{attrs:{href:"#主流程"}},[a._v("主流程")])]),r("li",[r("a",{attrs:{href:"#示例"}},[a._v("示例")])])])]),r("li",[r("a",{attrs:{href:"#解析和dom树构建"}},[a._v("解析和dom树构建")]),r("ul",[r("li",[r("a",{attrs:{href:"#html解析"}},[a._v("html解析")])]),r("li",[r("a",{attrs:{href:"#css解析"}},[a._v("css解析")])]),r("li",[r("a",{attrs:{href:"#处理js-css顺序"}},[a._v("处理js,css顺序")])])])]),r("li",[r("a",{attrs:{href:"#呈现树构建"}},[a._v("呈现树构建")]),r("ul",[r("li",[r("a",{attrs:{href:"#流程"}},[a._v("流程")])]),r("li",[r("a",{attrs:{href:"#样式计算"}},[a._v("样式计算")])]),r("li",[r("a",{attrs:{href:"#布局"}},[a._v("布局")])]),r("li",[r("a",{attrs:{href:"#domready"}},[a._v("DomReady")])])])]),r("li",[r("a",{attrs:{href:"#css-js对dom解析渲染的影响"}},[a._v("css,js对dom解析渲染的影响")]),r("ul",[r("li",[r("a",{attrs:{href:"#css"}},[a._v("css")])]),r("li",[r("a",{attrs:{href:"#js"}},[a._v("js")])]),r("li",[r("a",{attrs:{href:"#图层"}},[a._v("图层")])]),r("li",[r("a",{attrs:{href:"#重绘repaint和回流reflow"}},[a._v("重绘Repaint和回流Reflow")])])])])])]),r("p"),a._v(" "),r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),r("p",[a._v("网络浏览器很可能是使用最广的软件。介绍它们的幕后工作原理。会了解到，从在地址栏输入 baidu.com 直到在浏览器屏幕上看到 baidu 首页的整个过程中都发生了些什么。")]),a._v(" "),r("h3",{attrs:{id:"讨论的浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#讨论的浏览器","aria-hidden":"true"}},[a._v("#")]),a._v(" 讨论的浏览器")]),a._v(" "),r("p",[a._v("主流浏览器:Firefox、Chrome 浏览器和 Safari（部分开源）。")]),a._v(" "),r("h3",{attrs:{id:"主要功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主要功能","aria-hidden":"true"}},[a._v("#")]),a._v(" 主要功能")]),a._v(" "),r("p",[a._v("主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。")]),a._v(" "),r("p",[a._v("浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。")]),a._v(" "),r("h3",{attrs:{id:"高层结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高层结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 高层结构")]),a._v(" "),r("ul",[r("li",[a._v("用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面")]),a._v(" "),r("li",[a._v("浏览器引擎：在用户界面和呈现引擎之间传送指令")]),a._v(" "),r("li",[a._v("呈现引擎：负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上")]),a._v(" "),r("li",[a._v("网络：用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现")]),a._v(" "),r("li",[a._v("用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法")]),a._v(" "),r("li",[a._v("JavaScript 解释器\n数据存储：这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。")])]),a._v(" "),r("h2",{attrs:{id:"呈现引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#呈现引擎","aria-hidden":"true"}},[a._v("#")]),a._v(" 呈现引擎")]),a._v(" "),r("h3",{attrs:{id:"各浏览器引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#各浏览器引擎","aria-hidden":"true"}},[a._v("#")]),a._v(" 各浏览器引擎")]),a._v(" "),r("p",[a._v("Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。")]),a._v(" "),r("h3",{attrs:{id:"主流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主流程","aria-hidden":"true"}},[a._v("#")]),a._v(" 主流程")]),a._v(" "),r("p",[a._v("呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。然后进行基本流程：")]),a._v(" "),r("ol",[r("li",[a._v("呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成 “内容树” 上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：“呈现树”。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。")]),a._v(" "),r("li",[a._v("呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。")]),a._v(" "),r("li",[a._v("下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。")])]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),r("p",[a._v("需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。")])]),a._v(" "),r("h3",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例","aria-hidden":"true"}},[a._v("#")]),a._v(" 示例")]),a._v(" "),r("p",[r("img",{attrs:{src:s(165),alt:"An image"}})]),a._v(" "),r("h2",{attrs:{id:"解析和dom树构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解析和dom树构建","aria-hidden":"true"}},[a._v("#")]),a._v(" 解析和dom树构建")]),a._v(" "),r("h3",{attrs:{id:"html解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#html解析","aria-hidden":"true"}},[a._v("#")]),a._v(" html解析")]),a._v(" "),r("h3",{attrs:{id:"css解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css解析","aria-hidden":"true"}},[a._v("#")]),a._v(" css解析")]),a._v(" "),r("h3",{attrs:{id:"处理js-css顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#处理js-css顺序","aria-hidden":"true"}},[a._v("#")]),a._v(" 处理js,css顺序")]),a._v(" "),r("ul",[r("li",[a._v("script：网络的模型是同步的。网页作者希望解析器遇到 script 标记时立即解析并执行js。文档的解析将停止，直到js执行完毕。如果js是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将js标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将js标记为异步，以便由其他线程解析和执行。")]),a._v(" "),r("li",[a._v("style: 另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是js在文档解析阶段会请求【样式信息】。如果当时还没有加载和解析样式，js就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有js。而对于 WebKit 而言，仅当js尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该js。")])]),a._v(" "),r("h2",{attrs:{id:"呈现树构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#呈现树构建","aria-hidden":"true"}},[a._v("#")]),a._v(" 呈现树构建")]),a._v(" "),r("p",[a._v("在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),r("p",[a._v("呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。")])]),a._v(" "),r("h3",{attrs:{id:"流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流程","aria-hidden":"true"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),r("p",[a._v("在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。")]),a._v(" "),r("p",[a._v("在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。")]),a._v(" "),r("h3",{attrs:{id:"样式计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#样式计算","aria-hidden":"true"}},[a._v("#")]),a._v(" 样式计算")]),a._v(" "),r("h3",{attrs:{id:"布局"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局","aria-hidden":"true"}},[a._v("#")]),a._v(" 布局")]),a._v(" "),r("p",[a._v("呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),r("p",[a._v("全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：\n影响所有呈现器的全局样式更改，例如字体大小更改。\n屏幕大小调整。")])]),a._v(" "),r("h3",{attrs:{id:"domready"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#domready","aria-hidden":"true"}},[a._v("#")]),a._v(" DomReady")]),a._v(" "),r("ul",[r("li",[a._v("Load:指示页面包含图片等文件在内的所有元素都加载完成")]),a._v(" "),r("li",[a._v("ready：表示文档结构已经加载完成（不包含图片等非文字媒体文件）")]),a._v(" "),r("li",[a._v("DOMContentLoaded: 当页面的DOM树解析好并且需要等待JS执行完才触发，不直接等待CSS文件、图片的加载完成")]),a._v(" "),r("li",[a._v("onreadytstatechange：当对象状态变更时触发这个事件，一旦document的readyState属性发生变化就会触发")])]),a._v(" "),r("h2",{attrs:{id:"css-js对dom解析渲染的影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-js对dom解析渲染的影响","aria-hidden":"true"}},[a._v("#")]),a._v(" css,js对dom解析渲染的影响")]),a._v(" "),r("p",[a._v("一开始学前端，都听过，尽量将css放头部，js放底部，这样可以提高页面的性能。")]),a._v(" "),r("h3",{attrs:{id:"css"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css","aria-hidden":"true"}},[a._v("#")]),a._v(" css")]),a._v(" "),r("ul",[r("li",[a._v("结论：CSS 不会阻塞 DOM 的解析，但会阻塞页面渲染")]),a._v(" "),r("li",[a._v("原因：浏览器是解析DOM生成DOM Tree，结合CSS生成的CSS Tree，最终组成render tree，再渲染页面。由此可见，在此过程中CSS完全无法影响DOM Tree，因而无需阻塞DOM解析。然而，DOM Tree和CSS Tree会组合成render tree。如果CSS 不会阻塞页面阻塞渲染，那么CSS文件下载之前，浏览器就会渲染出一个浅绿色的div，之后再变成浅蓝色。浏览器的这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个原始的模样，待CSS下载完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。因此，基于性能与用户体验的考虑，浏览器会尽量减少渲染的次数，CSS顺理成章地阻塞页面渲染。也有另外的情况，css会影响js执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。")])]),a._v(" "),r("h3",{attrs:{id:"js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js","aria-hidden":"true"}},[a._v("#")]),a._v(" js")]),a._v(" "),r("ul",[r("li",[a._v("结论：JS 阻塞 DOM 解析")]),a._v(" "),r("li",[a._v("浏览器遇到 script 且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。")])]),a._v(" "),r("h3",{attrs:{id:"图层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图层","aria-hidden":"true"}},[a._v("#")]),a._v(" 图层")]),a._v(" "),r("blockquote",[r("p",[a._v("一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。")])]),a._v(" "),r("p",[a._v("通过以下几个常用属性可以生成新图层:")]),a._v(" "),r("ul",[r("li",[a._v("3D:translate3d、translateZ")]),a._v(" "),r("li",[a._v("will-change")]),a._v(" "),r("li",[a._v("video,iframe 标签")]),a._v(" "),r("li",[a._v("position: fixed")])]),a._v(" "),r("h3",{attrs:{id:"重绘repaint和回流reflow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重绘repaint和回流reflow","aria-hidden":"true"}},[a._v("#")]),a._v(" 重绘Repaint和回流Reflow")]),a._v(" "),r("ul",[r("li",[a._v("重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘")]),a._v(" "),r("li",[a._v("回流是布局或者几何属性需要改变就称为回流。\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。")])]),a._v(" "),r("p",[a._v("优化建议：")]),a._v(" "),r("ul",[r("li",[a._v("使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）")]),a._v(" "),r("li",[a._v("把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来")]),a._v(" "),r("li",[a._v("不要把 DOM 结点的属性值放在一个循环里当成循环里的变量")]),a._v(" "),r("li",[a._v("将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。")]),a._v(" "),r("li",[a._v("动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame")])])])}],e=s(0),i=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);i.options.__file="browser.md";t.default=i.exports}}]);