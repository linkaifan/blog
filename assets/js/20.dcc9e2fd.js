(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{195:function(t,a,e){"use strict";e.r(a);var r=e(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"前端性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 前端性能优化")]),t._v(" "),e("h3",{attrs:{id:"性能指标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能指标","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能指标")]),t._v(" "),e("ol",[e("li",[t._v("首屏First Paint")])]),t._v(" "),e("blockquote",[e("p",[t._v("浏览器第一次渲染(paint)，在First paint之前是白屏，在这个时间点之后用户就能看到（部分）页面内容。FP发生在body中第一个script脚本之前的CSS解析和JS执行完成之后。换句话说就是第一脚本之前的DOM和CSSOM准备就绪之后，便会着手渲染第一脚本前的内容。如果第一脚本前的JS和CSS加载完了，body中的脚本还未下载完成，那么浏览器就会利用构建好的局部CSSOM和DOM提前渲染第一脚本前的内容（触发FP）；如果第一脚本前的JS和CSS都还没下载完成，body中的脚本就已经下载完了，那么浏览器就会在所有JS脚本都执行完之后才触发FP。")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("DOMContentLoaded")])]),t._v(" "),e("blockquote",[e("p",[t._v("当文档中没有脚本时，浏览器解析完html文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等 CSSOM 构建完成才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。")])]),t._v(" "),e("h3",{attrs:{id:"性能监控performance"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能监控performance","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能监控performance")]),t._v(" "),e("p",[t._v("Performance 接口可以获取到当前页面中与性能相关的信息,可以通过调用只读属性 Window.performance 来获得。")]),t._v(" "),e("ul",[e("li",[t._v("timing: 提供了各种与浏览器处理相关的时间数据")]),t._v(" "),e("li",[t._v("navagation: 呈现了如何导航到当前文档的信息。有两个key\n"),e("ul",[e("li",[t._v("type: 表示如何导航到当前页面的，主要有4个值。【0,1,2,255】")]),t._v(" "),e("li",[t._v("redirectCount: 表示到达当前页面之前经过几次重定向。")])])]),t._v(" "),e("li",[t._v("timeOrigin: 表示performance性能测试开始的时间。是一个高精度时间戳")]),t._v(" "),e("li",[t._v("onresourcetimingbufferfull: 表示当浏览器资源时间性能缓冲区已满时会触发的回调函数。")]),t._v(" "),e("li",[t._v("mark,measure: 用mark进行打点，就能通过measure取得两个点之间高精度的时间差。【Vue框架就频繁用到了mark和measure来测试程序性能。】")])]),t._v(" "),e("p",[t._v("常用计算：")]),t._v(" "),e("ul",[e("li",[t._v("DNS查询耗时 ：domainLookupEnd - domainLookupStart")]),t._v(" "),e("li",[t._v("TCP链接耗时 ：connectEnd - connectStart")]),t._v(" "),e("li",[t._v("request请求耗时 ：responseEnd - responseStart")]),t._v(" "),e("li",[t._v("解析dom树耗时 ： domComplete - domInteractive")]),t._v(" "),e("li",[t._v("白屏时间 ：responseStart - navigationStart")]),t._v(" "),e("li",[t._v("domready时间(用户可操作时间节点) ：domContentLoadedEventEnd - navigationStart")]),t._v(" "),e("li",[t._v("onload时间(总下载时间) ：loadEventEnd - navigationStart")])]),t._v(" "),e("h3",{attrs:{id:"减少http请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少http请求","aria-hidden":"true"}},[t._v("#")]),t._v(" 减少http请求")]),t._v(" "),e("ul",[e("li",[t._v("css雪碧图：将所有图片合并成一张大图，使用时再结合background的position等属性来调整抠图。\n"),e("ul",[e("li",[t._v("缺点：开发抠图辛苦，而且会有邻边暴露问题")])])]),t._v(" "),e("li",[t._v("合并脚本和样式表：将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。\n"),e("ul",[e("li",[t._v("缺点: 若有更新就需要重下整个文件,且对于模块化开发不友好。")])])]),t._v(" "),e("li",[t._v("内联图片：将图片进行base64编码嵌入到文档或样式表中，整个文件会包含图片一起返回而不会产生额外http请求\n"),e("ul",[e("li",[t._v("缺点：不能缓存")])])])]),t._v(" "),e("h3",{attrs:{id:"cdn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn","aria-hidden":"true"}},[t._v("#")]),t._v(" CDN")]),t._v(" "),e("blockquote",[e("p",[t._v("使用一组分布在不同地方的服务器，根据网络流量，节点链接，负载情况以及用户距离，响应时间等因素将用户请求重定向到对用户来说最优的服务器上")])]),t._v(" "),e("p",[t._v("这样就能缩短响应时间，还能备份，扩展存储，缓解流量峰值等")]),t._v(" "),e("ul",[e("li",[t._v("缺点：响应时间可能会受到其他网站流量的影响等。")])]),t._v(" "),e("h3",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),e("p",[t._v("二次访问从本地缓存池中获取，不必每次访问都传输【详情见缓存篇】")]),t._v(" "),e("h3",{attrs:{id:"压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩","aria-hidden":"true"}},[t._v("#")]),t._v(" 压缩")]),t._v(" "),e("p",[t._v("使用gzip等压缩方式：\n请求头：Accept-Encoding: gzip, deflate（表示自己支持的压缩方式）\n响应头：Content-Endcding:gzip(实体头，表示实体的压缩方式)")]),t._v(" "),e("h3",{attrs:{id:"js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js","aria-hidden":"true"}},[t._v("#")]),t._v(" js")]),t._v(" "),e("p",[t._v("当 HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。")]),t._v(" "),e("p",[t._v("优化建议：JS放在 body闭标签 前，或使用异步脚本。")]),t._v(" "),e("ul",[e("li",[t._v("异步脚本\n"),e("ol",[e("li",[t._v("defer：在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。【DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。】")]),t._v(" "),e("li",[t._v("后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。【DOMContentLoaded 触发，而不需要等待 async 脚本执行、样式表加载等等。】")])])])]),t._v(" "),e("h3",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css","aria-hidden":"true"}},[t._v("#")]),t._v(" css")]),t._v(" "),e("p",[t._v("优化建议：放在head里。")]),t._v(" "),e("h3",{attrs:{id:"防抖和节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流","aria-hidden":"true"}},[t._v("#")]),t._v(" 防抖和节流")]),t._v(" "),e("p",[t._v("详见工具篇。")]),t._v(" "),e("h3",{attrs:{id:"图片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片","aria-hidden":"true"}},[t._v("#")]),t._v(" 图片")]),t._v(" "),e("ul",[e("li",[t._v("懒加载:只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。")])])])}],!1,null,null,null);i.options.__file="性能优化.md";a.default=i.exports}}]);